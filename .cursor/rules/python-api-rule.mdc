---
description: This rule is helpful for building project in python, you should refer to this rule when you found yourself writing python code.
globs: api/*.py
alwaysApply: false
---

# Flask-RESTful and WebSocket Development Guide

You are an expert in Python, Flask, Flask-RESTful, and WebSocket development for scalable API services.

Key Principles

- Write concise, technical responses with accurate Python examples.
- Use functional, declarative programming; prefer classes only when necessary (e.g., Resource classes for Flask-RESTful).
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission).
- Use lowercase with underscores for directories and files (e.g., api/observability/health.py).
- Use the Receive an Object, Return an Object (RORO) pattern where applicable.
- Manage runtime within python virtual environment, this has been already included in the @venv folder.
- Manage dependencies with uv, there is one [pyproject.toml](mdc:pyproject.toml) in the codebase.
- Always run the command with uv.

Python/Flask-RESTful

- Use type hints for all function signatures and method definitions.
- Use Pydantic models or Marshmallow schemas for input validation and response serialization.
- File structure: Resource classes in api/ subdirectories, organized by domain (e.g., api/observability/, api/funds/).
- Use Flask-RESTful Resource classes for HTTP endpoints, inheriting from flask_restful.Resource.
- Implement HTTP methods (get, post, put, delete, patch) as class methods.
- Return tuples of (dict, status_code) or (dict, status_code, headers) from Resource methods.
- Use http.HTTPStatus enum for status codes instead of magic numbers.
- Register resources using api.add_resource(ResourceClass, "/path", "/path/<int:resource_id>") in app.py.

Flask-RESTful Resource Patterns

```python
from flask_restful import Resource
from http import HTTPStatus
import logging

logger = logging.getLogger(__name__)

class MyResource(Resource):
    def get(self, id: int | None = None):
        """Handle GET requests."""
        try:
            # Validation and business logic
            if id is None:
                return {"items": []}, HTTPStatus.OK
            return {"id": id}, HTTPStatus.OK
        except ValueError as e:
            logger.error(f"Validation error: {e}")
            return {"error": str(e)}, HTTPStatus.BAD_REQUEST
        except Exception as e:
            logger.exception(f"Unexpected error: {e}")
            return {"error": "Internal server error"}, HTTPStatus.INTERNAL_SERVER_ERROR

    def post(self):
        """Handle POST requests."""
        data = request.get_json() or {}
        # Validate and process data
        return {"id": 1, "message": "Created"}, HTTPStatus.CREATED
```

WebSocket Connection Guidelines

- Use flask-socketio for WebSocket support in Flask applications.
- Initialize SocketIO with the Flask app: `socketio = SocketIO(app, cors_allowed_origins="*")`.
- Use @socketio.on() decorator for WebSocket event handlers.
- Implement proper connection/disconnection handlers.
- Use rooms and namespaces for organizing WebSocket connections.
- Emit events using socketio.emit() or socketio.send() for broadcasting.
- Handle errors gracefully in WebSocket event handlers.
- Use type hints for WebSocket event handler functions.

WebSocket Patterns

```python
from flask import Flask
from flask_socketio import SocketIO, emit, join_room, leave_room
from flask_restful import Api
import logging

logger = logging.getLogger(__name__)

app = Flask(__name__)
api = Api(app)
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading')

@socketio.on('connect')
def handle_connect(auth: dict | None = None):
    """Handle WebSocket connection."""
    logger.info(f"Client connected: {request.sid}")
    emit('connected', {'message': 'Connected successfully'})

@socketio.on('disconnect')
def handle_disconnect():
    """Handle WebSocket disconnection."""
    logger.info(f"Client disconnected: {request.sid}")

@socketio.on('join')
def handle_join(data: dict):
    """Handle joining a room."""
    room = data.get('room')
    if room:
        join_room(room)
        emit('joined', {'room': room}, room=room)

@socketio.on('message')
def handle_message(data: dict):
    """Handle incoming WebSocket message."""
    try:
        # Process message
        message = data.get('message', '')
        room = data.get('room')
        if room:
            socketio.emit('response', {'message': message}, room=room)
        else:
            emit('response', {'message': message})
    except Exception as e:
        logger.exception(f"Error handling message: {e}")
        emit('error', {'error': 'Failed to process message'})
```

Error Handling and Validation

- Prioritize error handling and edge cases:
  - Handle errors and edge cases at the beginning of functions/methods.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use the if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging with logger.error() or logger.exception().
  - Return user-friendly error messages with appropriate HTTP status codes.
  - Use custom exception classes for domain-specific errors.
- For Flask-RESTful: Return error responses as ({"error": "message"}, HTTPStatus.XXX).
- For WebSocket: Emit error events using emit('error', {'error': 'message'}).
- Use request.get_json(silent=True) or request.get_json() with proper error handling.

Request Parsing and Validation

- Use request.get_json() for JSON payloads, with proper None checking.
- Validate required fields early in the method.
- Use Pydantic models or Marshmallow schemas for complex validation.
- Return 400 Bad Request for validation errors with descriptive messages.
- Use request.args for query parameters and request.form for form data.

Dependencies

- Flask >= 3.0.2
- Flask-RESTful >= 0.3.10
- Flask-SocketIO >= 5.x (for WebSocket support)
- Flask-CORS >= 4.0.0 (for CORS handling)
- Pydantic v2 (for data validation)
- Marshmallow >= 3.21.1 (alternative for serialization)
- SQLAlchemy 2.0 (if using ORM features)
- Werkzeug >= 3.0.1

Flask Application Structure

- Initialize Flask app in app.py: `app = Flask(__name__)`.
- Initialize Flask-RESTful API: `api = Api(app)`.
- Initialize SocketIO if using WebSocket: `socketio = SocketIO(app, cors_allowed_origins="*")`.
- Register resources using `api.add_resource(ResourceClass, "/path", "/path/<id>")`.
- Use Flask error handlers for global error handling: `@app.errorhandler(404)`.
- Organize resources in api/ subdirectories by domain.
- Use __init__.py files to organize package structure.

Flask-Specific Guidelines

- Use Resource classes for RESTful endpoints, not function-based routes.
- Use Flask's request object for accessing request data (request.get_json(), request.args, request.form).
- Use jsonify() for JSON responses in error handlers, but return dicts from Resource methods (Flask-RESTful handles serialization).
- Use Flask's logging: `logger = logging.getLogger(__name__)`.
- Configure CORS using Flask-CORS: `CORS(app)` or per-route with `@cross_origin()`.
- Use Flask's application context when needed (e.g., in background tasks).
- Use Flask's before_request and after_request hooks for cross-cutting concerns.

Performance Optimization

- Minimize blocking I/O operations; consider using threading or async patterns for long-running tasks.
- Implement caching for static and frequently accessed data using tools like Redis or Flask-Caching.
- Use connection pooling for database connections.
- Optimize JSON serialization by returning appropriate data structures.
- Use lazy loading techniques for large datasets.
- For WebSocket: Use rooms to broadcast only to relevant clients instead of broadcasting to all.
- Consider using message queues (e.g., Redis with SocketIO) for scaling WebSocket across multiple workers.

Security Best Practices

- Validate and sanitize all user inputs.
- Use HTTPS in production.
- Implement proper authentication and authorization (e.g., Flask-JWT-Extended, Flask-Login).
- Use CORS appropriately; avoid allowing all origins in production.
- Sanitize WebSocket messages before processing.
- Implement rate limiting for API endpoints.
- Use environment variables for sensitive configuration (e.g., secrets, API keys).

How to run the test?

You should always run the test for your code. You can run the following commands to verify:

```bash
uv run python -m pytest tests/unit -v
```

You should fix your code if you found your code fail the test cases.

Key Conventions

1. Organize Flask-RESTful resources in api/ subdirectories by domain (e.g., api/observability/, api/funds/).
2. Each Resource class should handle one resource type with appropriate HTTP methods.
3. Use consistent error response format: {"error": "message"} for errors, {"data": ...} for success.
4. Register all resources in app.py using api.add_resource().
5. Use HTTPStatus enum for status codes consistently.
6. For WebSocket: Use descriptive event names and document them clearly.
7. Handle WebSocket connection lifecycle properly (connect, disconnect, error events).
8. Use logging consistently throughout the application.
9. Structure routes and resources clearly to optimize readability and maintainability.

Example Project Structure

```text
api/
  __init__.py
  observability/
    __init__.py
    health.py          # HealthCheck Resource
  funds/
    __init__.py
    fund_resource.py   # Fund-related Resources
app.py                 # Flask app, Api, SocketIO initialization, resource registration
core/
  websocket/
    handlers.py        # WebSocket event handlers
```

Refer to Flask-RESTful and Flask-SocketIO documentation for best practices and advanced patterns.
